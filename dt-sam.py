import tkinter as tk
from tkinter import filedialog, messagebox
from PIL import Image, ImageTk, ImageDraw
import numpy as np
import os
import cv2
from segment_anything import sam_model_registry, SamPredictor
import matplotlib.pyplot as plt
from skimage.color import label2rgb
import struct # For writing binary data for .pfm
import sys # Import sys to access command-line arguments

# --- Global Variables ---
# SAM Model and Predictor
sam_model = None
predictor = None
# Path to the SAM model checkpoint (MAKE SURE TO UPDATE THIS PATH)
sam_checkpoint_path = "path/to/model/weights/sam_vit_b_01ec64.pth" # Make sure this file is in the same directory!
model_type = "vit_b" # Corresponds to the vit_h checkpoint
image_file_path = None  # Stores the path of the currently loaded image

# Image and Mask Data
original_image_pil = None  # Stores the original PIL image
display_image_pil = None   # Stores the PIL image currently displayed (with mask overlay)
tk_image = None            # Stores the PhotoImage for tkinter display
current_mask = None        # Stores the binary mask generated by SAM (numpy array)
input_points = []          # List of (x, y) coordinates clicked by the user
input_labels = []          # List of labels for input_points (1 for positive, 0 for negative)

# GUI Elements
root = None
canvas = None
status_label = None

# --- SAM Model Loading Function ---
def load_sam_model():
    """Loads the Segment Anything Model."""
    global sam_model, predictor, status_label
    try:
        status_label.config(text="Loading SAM model... This may take a moment.")
        root.update_idletasks() # Update GUI to show message
        print(f"Loading SAM model from: {sam_checkpoint_path}")
        sam_model = sam_model_registry[model_type](checkpoint=sam_checkpoint_path)
        # If you have a GPU and CUDA is available, uncomment the line below
        # sam_model.to(device="cuda")
        predictor = SamPredictor(sam_model)
        status_label.config(text="SAM model loaded successfully. Ready to open image.")
        print("SAM model loaded successfully.")
    except FileNotFoundError:
        messagebox.showerror("Error", f"SAM model checkpoint not found at: {sam_checkpoint_path}\n"
                                      "Please download model weights (e.g. 'sam_vit_b_01ec64.pth') and place it in the same directory as this script.")
        status_label.config(text="Error: SAM model checkpoint not found.")
    except Exception as e:
        messagebox.showerror("Error", f"Failed to load SAM model: {e}")
        status_label.config(text="Error loading SAM model.")

# --- Image Handling Functions ---
def open_image_file(file_path=None):
    global original_image_pil, tk_image, current_mask, input_points, input_labels, status_label, image_file_path

    if file_path is None:
        file_path = filedialog.askopenfilename(
            title="Select Image File",
            filetypes=[("Image Files", "*.png *.jpg *.jpeg *.bmp *.gif *.tiff")]
        )

    if file_path:
        try:
            original_image_pil = Image.open(file_path).convert("RGB")
            image_file_path = file_path  # Store the path
            # Clear previous selections and mask
            input_points = []
            input_labels = []
            current_mask = None
            status_label.config(text=f"Image loaded: {os.path.basename(file_path)}. Click to segment.")
            update_display()
        except Exception as e:
            messagebox.showerror("Error", f"Failed to open image: {e}")
            status_label.config(text="Error opening image.")

def update_display():
    """Updates the canvas with the current image and mask overlay."""
    global original_image_pil, display_image_pil, tk_image, current_mask, canvas

    if original_image_pil is None:
        canvas.delete("all")
        return

    # Create a copy of the original image for drawing
    display_image_pil = original_image_pil.copy()
    draw = ImageDraw.Draw(display_image_pil)

    # Draw input points
    for i, (x, y) in enumerate(input_points):
        radius = 5
        color = "red" if input_labels[i] == 1 else "blue" # Red for positive, Blue for negative
        draw.ellipse((x - radius, y - radius, x + radius, y + radius), fill=color, outline="white")

    # Overlay the mask if it exists
    if current_mask is not None:
        # Convert boolean mask to RGBA for overlay
        mask_overlay = Image.fromarray((current_mask * 255).astype(np.uint8)).convert("RGBA")
        # Set alpha for transparency (e.g., 50%)
        alpha = 128 # 0-255
        mask_overlay_data = mask_overlay.getdata()
        new_mask_overlay_data = []
        for item in mask_overlay_data:
            if item[0] == 255: # If it's a mask pixel (white)
                new_mask_overlay_data.append((255, 0, 0, alpha)) # Red with transparency
            else:
                new_mask_overlay_data.append((0, 0, 0, 0)) # Fully transparent
        mask_overlay.putdata(new_mask_overlay_data)

        # Composite the mask onto the image
        display_image_pil = Image.alpha_composite(display_image_pil.convert("RGBA"), mask_overlay).convert("RGB")


    # Resize image to fit canvas while maintaining aspect ratio
    canvas_width = canvas.winfo_width()
    canvas_height = canvas.winfo_height()

    if canvas_width == 1 or canvas_height == 1: # Default size before window is drawn
        canvas_width = 800
        canvas_height = 600

    img_width, img_height = display_image_pil.size
    ratio = min(canvas_width / img_width, canvas_height / img_height)
    new_width = int(img_width * ratio)
    new_height = int(img_height * ratio)

    resized_image = display_image_pil.resize((new_width, new_height), Image.Resampling.LANCZOS)
    tk_image = ImageTk.PhotoImage(resized_image)

    canvas.delete("all")
    canvas.create_image(canvas_width / 2, canvas_height / 2, anchor=tk.CENTER, image=tk_image)
    canvas.config(scrollregion=canvas.bbox(tk.ALL)) # Update scroll region

# --- SAM Segmentation Logic ---
def run_sam_segmentation():
    """Runs SAM prediction based on current input points."""
    global predictor, original_image_pil, current_mask, status_label

    if original_image_pil is None:
        messagebox.showwarning("No Image", "Please open an image first.")
        return
    if not input_points:
        messagebox.showwarning("No Clicks", "Please click on the image to select points for segmentation.")
        return
    if predictor is None:
        messagebox.showerror("Error", "SAM predictor is not loaded. Please restart or check model path.")
        return

    try:
        status_label.config(text="Running SAM segmentation...")
        root.update_idletasks()

        # Convert PIL image to numpy array for SAM
        image_np = np.array(original_image_pil)
        predictor.set_image(image_np)

        # Convert input points to numpy array
        points_np = np.array(input_points)
        labels_np = np.array(input_labels)

        # Predict masks
        masks, scores, logits = predictor.predict(
            point_coords=points_np,
            point_labels=labels_np,
            multimask_output=False, # Set to False for single, most confident mask
        )

        # Get the first (and usually best) mask
        current_mask = masks[0] # This is a boolean numpy array (True/False)
        status_label.config(text="Segmentation complete. Click more or save.")
        update_display()

    except Exception as e:
        messagebox.showerror("Segmentation Error", f"An error occurred during segmentation: {e}")
        status_label.config(text="Error during segmentation.")

# --- GUI Event Handlers ---
def on_mouse_click(event):
    """Handles mouse clicks on the canvas to add segmentation points."""
    global input_points, input_labels, original_image_pil, canvas

    if original_image_pil is None:
        messagebox.showwarning("No Image", "Please open an image first.")
        return

    # Get the actual image coordinates from canvas coordinates
    # Calculate scaling factor
    img_width, img_height = original_image_pil.size
    canvas_width = canvas.winfo_width()
    canvas_height = canvas.winfo_height()

    if canvas_width == 1 or canvas_height == 1: # Default size before window is drawn
        canvas_width = 800
        canvas_height = 600

    ratio = min(canvas_width / img_width, canvas_height / img_height)
    new_width = int(img_width * ratio)
    new_height = int(img_height * ratio)

    # Calculate offset for centered image
    offset_x = (canvas_width - new_width) / 2
    offset_y = (canvas_height - new_height) / 2

    # Convert canvas click to image coordinates
    img_x = int((event.x - offset_x) / ratio)
    img_y = int((event.y - offset_y) / ratio)

    # Ensure coordinates are within image bounds
    if 0 <= img_x < img_width and 0 <= img_y < img_height:
        # Left click (button 1) for positive point
        if event.num == 1:
            input_points.append([img_x, img_y])
            input_labels.append(1) # Positive point
            status_label.config(text=f"Added positive point at ({img_x}, {img_y}).")
        # Right click (button 3) for negative point (to exclude areas)
        elif event.num == 3:
            input_points.append([img_x, img_y])
            input_labels.append(0) # Negative point
            status_label.config(text=f"Added negative point at ({img_x}, {img_y}).")

        run_sam_segmentation()
    else:
        status_label.config(text="Click outside image bounds. Please click within the image.")


def clear_selections():
    """Clears all input points and the current mask."""
    global input_points, input_labels, current_mask, status_label
    input_points = []
    input_labels = []
    current_mask = None
    status_label.config(text="Selections cleared. Click to segment new areas.")
    update_display()

def save_mask_as_pfm():
    global current_mask, original_image_pil, image_file_path

    if current_mask is None:
        messagebox.showwarning("No Mask", "No mask has been generated yet. Please segment an image first.")
        return

    if image_file_path is None:
        messagebox.showwarning("No Image Info", "Original image information is missing. Cannot determine default save path.")
        default_filename = "segmented_mask.pfm"
        initialdir = os.getcwd()
    else:
        base_name = os.path.splitext(os.path.basename(image_file_path))[0]
        default_filename = f"{base_name}_mask.pfm"
        initialdir = os.path.dirname(image_file_path)

    file_path = filedialog.asksaveasfilename(
        title="Save Segmented Mask as .pfm",
        initialfile=default_filename,
        initialdir=initialdir,
        defaultextension=".pfm",
        filetypes=[("PFM FloatMap Files", "*.pfm"), ("All Files", "*.*")]
    )

    if file_path:
        try:
            # Convert boolean mask to float32 (0.0 or 1.0)
            mask_data_float = current_mask.astype(np.float32)
            height, width = mask_data_float.shape
            header = f"Pf\n{width} {height}\n-1.0\n"
            with open(file_path, 'wb') as f:
                f.write(header.encode('ascii'))
                f.write(np.flipud(mask_data_float).tobytes())
            messagebox.showinfo("Save Successful", f"Mask saved successfully to:\n{file_path}\n"
                                                  "Note: This is a Portable FloatMap (.pfm) file.")
            status_label.config(text=f"Mask saved to {os.path.basename(file_path)}")
        except Exception as e:
            messagebox.showerror("Save Error", f"Failed to save mask: {e}")
            status_label.config(text="Error saving mask.")

def on_closing():
    """Handles the window closing event, prompting to save."""
    if current_mask is not None:
        if messagebox.askyesno("Save Mask?", "Do you want to save the segmented mask before exiting?"):
            save_mask_as_pfm() # Call the updated save function
    root.destroy()

# --- Main GUI Setup ---
def setup_gui():
    """Sets up the main Tkinter GUI window."""
    global root, canvas, status_label

    root = tk.Tk()
    root.title("Interactive SAM Segmentation")
    root.geometry("1000x800") # Initial window size

    # Configure grid weights for responsive layout
    root.grid_rowconfigure(0, weight=0) # Menu bar row
    root.grid_rowconfigure(1, weight=1) # Canvas row
    root.grid_rowconfigure(2, weight=0) # Buttons row
    root.grid_rowconfigure(3, weight=0) # Status bar row
    root.grid_columnconfigure(0, weight=1)

    # --- Menu Bar ---
    menu_bar = tk.Menu(root)
    root.config(menu=menu_bar)

    file_menu = tk.Menu(menu_bar, tearoff=0)
    menu_bar.add_cascade(label="File", menu=file_menu)
    file_menu.add_command(label="Open Image", command=open_image_file)
    file_menu.add_separator()
    file_menu.add_command(label="Exit", command=on_closing)

    # --- Canvas for Image Display ---
    canvas = tk.Canvas(root, bg="lightgray", bd=2, relief=tk.SUNKEN)
    canvas.grid(row=1, column=0, padx=10, pady=10, sticky="nsew")
    canvas.bind("<Button-1>", on_mouse_click)  # Left click for positive point
    canvas.bind("<Button-3>", on_mouse_click)  # Right click for negative point
    canvas.bind("<Configure>", lambda event: update_display()) # Re-draw on resize

    # --- Control Buttons ---
    button_frame = tk.Frame(root)
    button_frame.grid(row=2, column=0, pady=5)

    # New Open Image Button
    open_button = tk.Button(button_frame, text="Open Image", command=open_image_file,
                            font=("Arial", 10), bg="#C1E1FF", fg="black", relief=tk.RAISED, bd=3)
    open_button.pack(side=tk.LEFT, padx=10)

    clear_button = tk.Button(button_frame, text="Clear Selections", command=clear_selections,
                             font=("Arial", 10), bg="#FFDDC1", fg="black", relief=tk.RAISED, bd=3)
    clear_button.pack(side=tk.LEFT, padx=10)

    save_button = tk.Button(button_frame, text="Save Mask (.pfm)", command=save_mask_as_pfm,
                            font=("Arial", 10), bg="#D1FFC1", fg="black", relief=tk.RAISED, bd=3)
    save_button.pack(side=tk.LEFT, padx=10)

    # --- Status Bar ---
    status_label = tk.Label(root, text="Welcome! Load SAM model first.", bd=1, relief=tk.SUNKEN, anchor=tk.W)
    status_label.grid(row=3, column=0, sticky="ew", padx=5, pady=5)

    # Set protocol for window closing
    root.protocol("WM_DELETE_WINDOW", on_closing)

    # Load SAM model when the application starts
    load_sam_model()

    # Check for command-line argument for initial image
    if len(sys.argv) > 1:
        initial_file_path = sys.argv[1]
        # Use root.after to call open_image_file after the Tkinter mainloop has started
        # This prevents issues with Tkinter widgets not being fully initialized
        root.after(100, lambda: open_image_file(initial_file_path))

    root.mainloop()

# --- Run the GUI ---
if __name__ == "__main__":
    setup_gui()
